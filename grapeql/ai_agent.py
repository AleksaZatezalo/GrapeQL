"""
GrapeQL AI Agent
Author: Aleksa Zatezalo
Version: 1.0
Date: February 2025
Description: Post-scan AI analysis module. Sends collected findings to the
             Anthropic Messages API and returns a structured executive summary
             with prioritised next steps for further testing.
"""

import json
from typing import Dict, List, Optional

import httpx

from .utils import GrapePrinter, Finding

# ------------------------------------------------------------------ #
#  Constants
# ------------------------------------------------------------------ #

_API_URL = "https://api.anthropic.com/v1/messages"
_MODEL = "claude-sonnet-4-20250514"
_MAX_TOKENS = 4096
_API_VERSION = "2023-06-01"

_SYSTEM_PROMPT = """\
You are a senior penetration tester writing the AI-assisted analysis section \
of a GraphQL security assessment report generated by GrapeQL, an automated \
GraphQL vulnerability scanner.

You will receive:
  1. The target endpoint URL.
  2. A JSON array of findings produced by GrapeQL's scan modules.
  3. An optional free-form message from the operator.

Your job is to produce a concise, actionable Markdown section that will be \
appended directly to the report.  Use the following structure exactly:

## AI Analysis

### Executive Summary
Two to four sentences that characterise the overall security posture of the \
target based on the findings.  Mention the most critical issues first.

### Risk Analysis
For each CRITICAL or HIGH finding, write one short paragraph explaining the \
real-world impact and how an attacker could chain it with other findings.  \
If there are no CRITICAL/HIGH findings, note that the attack surface appears \
limited and summarise MEDIUM/LOW risks instead.

### Recommended Next Steps
A numbered list of concrete manual testing actions the operator should take \
next.  Prioritise by severity and exploitability.  Include specific GraphQL \
queries, mutations, or tool commands where possible.

### Gaps in Coverage
Briefly note any common GraphQL attack classes that the automated scan may \
have missed (e.g. business-logic flaws, access-control between roles, \
subscription abuse, batching attacks) and suggest how to test for them.

Rules:
- Write in third person ("the target", "the API").
- Be specific — reference finding titles and endpoints from the data.
- Do NOT repeat the raw finding descriptions verbatim; synthesise them.
- Keep the entire section under 800 words.
- Output raw Markdown only — no code fences around the whole response.
"""


# ------------------------------------------------------------------ #
#  AIAgent
# ------------------------------------------------------------------ #


class AIAgent:
    """
    Post-scan analysis module.

    Usage:
        agent = AIAgent(api_key="sk-ant-...")
        summary_md = await agent.analyse(
            target="http://localhost:5013/graphql",
            findings=[...],
            message="Focus on SSRF chains.",
        )
        # summary_md is a Markdown string ready to append to the report.
    """

    def __init__(self, api_key: str):
        self.api_key = api_key
        self.printer = GrapePrinter()

    # ------------------------------------------------------------------ #
    #  Internal helpers
    # ------------------------------------------------------------------ #

    def _build_user_prompt(
        self,
        target: str,
        findings: List[Finding],
        message: Optional[str] = None,
    ) -> str:
        """Assemble the user-turn content sent to the model."""
        findings_json = json.dumps(
            [f.to_dict() for f in findings], indent=2
        )

        parts = [
            f"**Target:** `{target}`\n",
            f"**Findings ({len(findings)} total):**\n```json\n{findings_json}\n```",
        ]

        if message:
            parts.append(f"\n**Operator message:** {message}")

        return "\n".join(parts)

    # ------------------------------------------------------------------ #
    #  Public API
    # ------------------------------------------------------------------ #

    async def analyse(
        self,
        target: str,
        findings: List[Finding],
        message: Optional[str] = None,
    ) -> Optional[str]:
        """
        Send findings to the Anthropic Messages API and return the AI
        analysis as a Markdown string.

        Returns ``None`` on failure (error is printed to console).
        """
        if not findings:
            self.printer.print_msg(
                "No findings to analyse — skipping AI summary", status="log"
            )
            return None

        self.printer.print_msg("Generating AI analysis...", status="log")

        user_content = self._build_user_prompt(target, findings, message)

        payload = {
            "model": _MODEL,
            "max_tokens": _MAX_TOKENS,
            "system": _SYSTEM_PROMPT,
            "messages": [{"role": "user", "content": user_content}],
        }

        headers = {
            "x-api-key": self.api_key,
            "anthropic-version": _API_VERSION,
            "content-type": "application/json",
        }

        try:
            async with httpx.AsyncClient(timeout=120) as client:
                resp = await client.post(_API_URL, json=payload, headers=headers)

            if resp.status_code != 200:
                body = resp.text[:500]
                self.printer.print_msg(
                    f"Anthropic API error ({resp.status_code}): {body}",
                    status="error",
                )
                return None

            data = resp.json()
            # Extract text blocks from the response content array
            text_parts = [
                block["text"]
                for block in data.get("content", [])
                if block.get("type") == "text"
            ]

            if not text_parts:
                self.printer.print_msg(
                    "Anthropic API returned no text content", status="error"
                )
                return None

            summary = "\n".join(text_parts)
            self.printer.print_msg("AI analysis complete", status="success")
            return summary

        except httpx.TimeoutException:
            self.printer.print_msg(
                "Anthropic API request timed out (120s)", status="error"
            )
            return None
        except httpx.RequestError as exc:
            self.printer.print_msg(
                f"Network error calling Anthropic API: {exc}", status="error"
            )
            return None
        except (KeyError, json.JSONDecodeError) as exc:
            self.printer.print_msg(
                f"Failed to parse Anthropic API response: {exc}", status="error"
            )
            return None